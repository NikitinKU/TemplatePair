#include <iostream>

/*
* Два множества называются непересекающимися, если они не имеют ни одного общего элемента, пересечение множеств является нулевым множеством.

Структура данных, которая хранит непересекающиеся или непересекающиеся подмножества элементов, называется структурой данных disjoint set. Структура данных disjoint set поддерживает следующие операции:

Добавление новых множеств в дизъюнктное множество.
Объединение непересекающихся множеств в одно непересекающееся множество с помощью операции Union.
Поиск представителя непересекающегося множества с помощью операции Find.
Проверка, являются ли два множества непересекающимися или нет.
*
Нам даны 10 индивидов, скажем, a, b, c, d, e, f, g, h, i, j.

Ниже перечислены отношения, которые необходимо добавить:ed:
a <-> b  
b <-> d
c <-> f
c <-> i
j <-> e
g <-> j

Задаются запросы типа: является ли a другом d или нет. 
В основном нам нужно создать следующие 4 группы и поддерживать быстро доступную связь между элементами группы:
G1 = {a, b, d}
G2 = {c, f, i}
G3 = {e, g, j}
G4 = {h}
* 
* 
Операции:
find: реализация путем рекурсивного обхода массива родителей (представителей) до тех пор, 
	пока мы не найдем узел, который является родителем самого себя.
union: принимает два элемента в кач-е входных данных, находит представителей их множеств с помощью операции find()
Помещает одно из деревьев (представляющее множество) в корневой узел другого дерева, эффективно объединяя деревья и множества.
*/

class DSU {
	int* parent, n;

public:
	DSU(int n) {
		parent = new int[n];
		this->n = n;
		makeSet();
	}

	void makeSet() {
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}

	int find(int i) {
		// Если i является родителем самого себя
		if (parent[i] == i) {
			// Тогда i является представителем
			// этого множества
			return i;
		}
		else {
			// Иначе, если i не является родителем самого себя, то i не является представителем этого множества.
			// Поэтому мы рекурсивно вызываем Find на его родителе
			return find(parent[i]);
		}
	}

	void Union(int i, int j) {
		//находим представителей (корневые узлы) для множества, включающих i
		int irepres = this->find(i);
		//находим представителей (корневые узлы) для множества, включающих j
		int jrepres = this->find(j);
		//Делаем родителя представителя i стать представителем j
		//Перемещая всё множество i в множество j
		this->parent[irepres] = jrepres;
	}
};

int main() {

	return 0;
}